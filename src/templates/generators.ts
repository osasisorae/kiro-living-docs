/**
 * Documentation generators for different types of documentation
 */

import { TemplateEngine } from './engine';
import { TemplateContext } from './types';
import { 
  DocumentationRequirement, 
  APIDefinition, 
  FeatureDescription, 
  ArchitecturalChange,
  ChangeAnalysis 
} from '../types';

export class DocumentationGenerators {
  constructor(private templateEngine: TemplateEngine) {}

  /**
   * Generate API specification documentation for .kiro/specs/ files
   */
  generateAPISpecification(
    apis: APIDefinition[], 
    description?: string
  ): DocumentationRequirement {
    // Verify template exists (for consistency checking)
    const template = this.templateEngine.getTemplate('api-doc');
    
    // Generate content directly with robust handling
    let content = '# API Documentation\n\n';
    
    content += '## Overview\n';
    content += `${description || 'API Documentation'}\n\n`;
    
    content += '## Endpoints\n\n';
    
    apis.forEach(api => {
      // Ensure we have valid data
      const apiName = (api.name || '').trim() || 'Unnamed API';
      
      content += `### ${apiName}\n`;
      
      if (api.method) {
        content += `**Method:** ${api.method}\n`;
      }
      
      if (api.path) {
        content += `**Path:** ${api.path}\n`;
      }
      
      content += '\n';
      
      if (api.description && api.description.trim()) {
        content += `${api.description.trim()}\n\n`;
      }
      
      if (api.parameters && api.parameters.length > 0) {
        content += '**Parameters:**\n';
        api.parameters.forEach(param => {
          const paramName = (param.name || '').trim() || 'unnamed';
          const paramType = param.type || 'unknown';
          const optional = param.optional ? ' - Optional' : '';
          const desc = param.description && param.description.trim() ? ` - ${param.description.trim()}` : '';
          content += `- \`${paramName}\` (${paramType})${optional}${desc}\n`;
        });
        content += '\n';
      }
      
      const returnType = api.returnType || 'unknown';
      content += `**Returns:** ${returnType}\n\n`;
    });
    
    content += '---\n';
    content += `*Generated on ${new Date().toISOString()}*`;

    return {
      type: 'api-spec',
      targetFile: '.kiro/specs/api.md',
      content,
      priority: 'high'
    };
  }

  /**
   * Generate README Features & API section updates
   */
  generateREADMESection(
    features: FeatureDescription[],
    apis: APIDefinition[]
  ): DocumentationRequirement {
    const featuresContent = this.generateFeaturesSection(features);
    const apiContent = this.generateAPISection(apis);
    
    const content = `## Features

${featuresContent}

## API

${apiContent}

---
*Last updated: ${new Date().toISOString()}*`;

    return {
      type: 'readme-section',
      targetFile: 'README.md',
      section: 'Features & API',
      content,
      priority: 'medium'
    };
  }

  /**
   * Generate development log entries
   */
  generateDevelopmentLogEntry(analysis: ChangeAnalysis): DocumentationRequirement {
    const timestamp = new Date().toISOString();
    const date = timestamp.split('T')[0];
    
    let content = `# Development Log Entry - ${date}

**Timestamp:** ${timestamp}
**Trigger:** ${analysis.triggerType}

## Changes Summary

`;

    // Add changed files
    if (analysis.changedFiles.length > 0) {
      content += `### Modified Files
${analysis.changedFiles.map(file => `- ${file.path} (${file.changeType})`).join('\n')}

`;
    }

    // Add new features
    if (analysis.newFeatures.length > 0) {
      content += `### New Features
${analysis.newFeatures.map(feature => `- **${feature.name}**: ${feature.description}`).join('\n')}

`;
    }

    // Add API changes
    if (analysis.extractedAPIs.length > 0) {
      content += `### API Changes
${analysis.extractedAPIs.map(api => `- ${api.name}: ${api.description || 'API endpoint updated'}`).join('\n')}

`;
    }

    // Add architectural changes
    if (analysis.architecturalChanges.length > 0) {
      content += `### Architectural Changes
${analysis.architecturalChanges.map(change => `- **${change.component}** (${change.type}): ${change.description} [Impact: ${change.impact}]`).join('\n')}

`;
    }

    // Add documentation requirements
    if (analysis.documentationRequirements.length > 0) {
      content += `### Documentation Updates Required
${analysis.documentationRequirements.map(req => `- ${req.type}: ${req.targetFile}${req.section ? ` (${req.section})` : ''}`).join('\n')}

`;
    }

    content += `---
*Auto-generated by auto-doc-sync system*`;

    return {
      type: 'dev-log',
      targetFile: `.kiro/development-log/${date}-${Date.now()}.md`,
      content,
      priority: 'low'
    };
  }

  /**
   * Generate setup instructions documentation
   */
  generateSetupInstructions(
    installCommand: string,
    configSteps?: string[],
    usageExample?: string,
    additionalNotes?: string
  ): DocumentationRequirement {
    // Verify template exists (for consistency checking)
    const template = this.templateEngine.getTemplate('setup-instructions');
    
    let content = '# Setup Instructions\n\n';
    
    content += '## Installation\n\n';
    content += `\`\`\`bash\n${installCommand || 'npm install'}\n\`\`\`\n\n`;
    
    content += '## Configuration\n\n';
    if (configSteps && configSteps.length > 0) {
      configSteps.forEach((step, index) => {
        const stepText = (step || '').trim();
        if (stepText) {
          content += `${index + 1}. ${stepText}\n`;
        }
      });
      content += '\n';
    } else {
      content += 'No additional configuration required.\n\n';
    }
    
    content += '## Usage\n\n';
    if (usageExample && usageExample.trim()) {
      content += `\`\`\`typescript\n${usageExample.trim()}\n\`\`\`\n\n`;
    }
    
    if (additionalNotes && additionalNotes.trim()) {
      content += '## Additional Notes\n\n';
      content += `${additionalNotes.trim()}\n\n`;
    }
    
    content += '---\n';
    content += `*Generated on ${new Date().toISOString()}*`;

    return {
      type: 'api-spec',
      targetFile: '.kiro/specs/setup.md',
      content,
      priority: 'medium'
    };
  }

  /**
   * Generate architecture notes documentation
   */
  generateArchitectureNotes(
    systemOverview: string,
    components: Array<{
      name: string;
      description: string;
      responsibilities?: string[];
      interfaces?: string[];
    }>,
    architecturalChanges?: ArchitecturalChange[]
  ): DocumentationRequirement {
    // Verify template exists (for consistency checking)
    const template = this.templateEngine.getTemplate('architecture-notes');
    
    let content = '# Architecture Notes\n\n';
    
    content += '## System Overview\n\n';
    content += `${systemOverview || 'System overview not provided.'}\n\n`;
    
    content += '## Components\n\n';
    components.forEach(component => {
      const componentName = (component.name || '').trim() || 'Unnamed Component';
      const componentDesc = (component.description || '').trim() || 'No description provided.';
      
      content += `### ${componentName}\n\n`;
      content += `${componentDesc}\n\n`;
      
      if (component.responsibilities && component.responsibilities.length > 0) {
        content += '**Responsibilities:**\n';
        component.responsibilities.forEach(resp => {
          const responsibility = (resp || '').trim();
          if (responsibility) {
            content += `- ${responsibility}\n`;
          }
        });
        content += '\n';
      }
      
      if (component.interfaces && component.interfaces.length > 0) {
        content += '**Interfaces:**\n';
        component.interfaces.forEach(iface => {
          const interfaceName = (iface || '').trim();
          if (interfaceName) {
            content += `- \`${interfaceName}\`\n`;
          }
        });
        content += '\n';
      }
    });
    
    if (architecturalChanges && architecturalChanges.length > 0) {
      content += '## Recent Changes\n\n';
      architecturalChanges.forEach(change => {
        const componentName = (change.component || '').trim() || 'Unknown Component';
        const changeType = change.type || 'unknown';
        const changeDesc = (change.description || '').trim() || 'No description provided.';
        const impact = change.impact || 'unknown';
        
        content += `### ${componentName} (${changeType})\n\n`;
        content += `${changeDesc}\n\n`;
        content += `**Impact:** ${impact}\n\n`;
      });
    }
    
    content += '---\n';
    content += `*Generated on ${new Date().toISOString()}*`;

    return {
      type: 'api-spec',
      targetFile: '.kiro/specs/architecture.md',
      content,
      priority: 'medium'
    };
  }

  private generateFeaturesSection(features: FeatureDescription[]): string {
    if (features.length === 0) {
      return 'No features documented yet.';
    }

    const categorized = {
      new: features.filter(f => f.category === 'new'),
      enhanced: features.filter(f => f.category === 'enhanced'),
      deprecated: features.filter(f => f.category === 'deprecated')
    };

    let content = '';

    if (categorized.new.length > 0) {
      content += '### New Features\n\n';
      content += categorized.new.map(f => {
        const name = (f.name || '').trim() || 'Unnamed Feature';
        const desc = (f.description || '').trim() || 'No description provided.';
        return `- **${name}**: ${desc}`;
      }).join('\n');
      content += '\n\n';
    }

    if (categorized.enhanced.length > 0) {
      content += '### Enhanced Features\n\n';
      content += categorized.enhanced.map(f => {
        const name = (f.name || '').trim() || 'Unnamed Feature';
        const desc = (f.description || '').trim() || 'No description provided.';
        return `- **${name}**: ${desc}`;
      }).join('\n');
      content += '\n\n';
    }

    if (categorized.deprecated.length > 0) {
      content += '### Deprecated Features\n\n';
      content += categorized.deprecated.map(f => {
        const name = (f.name || '').trim() || 'Unnamed Feature';
        const desc = (f.description || '').trim() || 'No description provided.';
        return `- **${name}**: ${desc}`;
      }).join('\n');
      content += '\n\n';
    }

    return content.trim();
  }

  private generateAPISection(apis: APIDefinition[]): string {
    if (apis.length === 0) {
      return 'No API endpoints documented yet.';
    }

    return apis.map(api => {
      const apiName = (api.name || '').trim() || 'Unnamed API';
      let apiDoc = `### ${apiName}\n\n`;
      
      if (api.method && api.path) {
        apiDoc += `\`${api.method} ${api.path}\`\n\n`;
      }
      
      if (api.description && api.description.trim()) {
        apiDoc += `${api.description.trim()}\n\n`;
      }

      if (api.parameters && api.parameters.length > 0) {
        apiDoc += '**Parameters:**\n';
        apiDoc += api.parameters.map(p => {
          const paramName = (p.name || '').trim() || 'unnamed';
          const paramType = p.type || 'unknown';
          const optional = p.optional ? ' - Optional' : '';
          const desc = p.description && p.description.trim() ? ` - ${p.description.trim()}` : '';
          return `- \`${paramName}\` (${paramType})${optional}${desc}`;
        }).join('\n');
        apiDoc += '\n\n';
      }

      const returnType = api.returnType || 'unknown';
      apiDoc += `**Returns:** ${returnType}\n\n`;
      
      return apiDoc;
    }).join('');
  }
}